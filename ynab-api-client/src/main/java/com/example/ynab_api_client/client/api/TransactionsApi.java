/*
 * YNAB API Endpoints
 * Our API uses a REST based design, leverages the JSON data format, and relies upon HTTPS for transport. We respond with meaningful HTTP response codes and if an error occurs, we include error details in the response body.  API Documentation is at https://api.ynab.com
 *
 * The version of the OpenAPI document: 1.75.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.example.ynab_api_client.client.api;

import com.example.ynab_api_client.client.invoker.ApiClient;
import com.example.ynab_api_client.client.invoker.ApiException;
import com.example.ynab_api_client.client.invoker.ApiResponse;
import com.example.ynab_api_client.client.invoker.Configuration;
import com.example.ynab_api_client.client.invoker.Pair;

import com.example.ynab_api_client.client.model.ErrorResponse;
import com.example.ynab_api_client.client.model.HybridTransactionsResponse;
import java.time.LocalDate;
import com.example.ynab_api_client.client.model.PatchTransactionsWrapper;
import com.example.ynab_api_client.client.model.PostTransactionsWrapper;
import com.example.ynab_api_client.client.model.PutTransactionWrapper;
import com.example.ynab_api_client.client.model.SaveTransactionsResponse;
import com.example.ynab_api_client.client.model.TransactionResponse;
import com.example.ynab_api_client.client.model.TransactionsImportResponse;
import com.example.ynab_api_client.client.model.TransactionsResponse;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-07-01T21:45:22.500220+02:00[Europe/Zurich]", comments = "Generator version: 7.14.0")
public class TransactionsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public TransactionsApi() {
    this(Configuration.getDefaultApiClient());
  }

  public TransactionsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Create a single transaction or multiple transactions
   * Creates a single transaction or multiple transactions.  If you provide a body containing a &#x60;transaction&#x60; object, a single transaction will be created and if you provide a body containing a &#x60;transactions&#x60; array, multiple transactions will be created.  Scheduled transactions (transactions with a future date) cannot be created on this endpoint.
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param data The transaction or transactions to create.  To create a single transaction you can specify a value for the &#x60;transaction&#x60; object and to create multiple transactions you can specify an array of &#x60;transactions&#x60;.  It is expected that you will only provide a value for one of these objects. (required)
   * @return SaveTransactionsResponse
   * @throws ApiException if fails to make API call
   */
  public SaveTransactionsResponse createTransaction(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull PostTransactionsWrapper data) throws ApiException {
    ApiResponse<SaveTransactionsResponse> localVarResponse = createTransactionWithHttpInfo(budgetId, data);
    return localVarResponse.getData();
  }

  /**
   * Create a single transaction or multiple transactions
   * Creates a single transaction or multiple transactions.  If you provide a body containing a &#x60;transaction&#x60; object, a single transaction will be created and if you provide a body containing a &#x60;transactions&#x60; array, multiple transactions will be created.  Scheduled transactions (transactions with a future date) cannot be created on this endpoint.
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param data The transaction or transactions to create.  To create a single transaction you can specify a value for the &#x60;transaction&#x60; object and to create multiple transactions you can specify an array of &#x60;transactions&#x60;.  It is expected that you will only provide a value for one of these objects. (required)
   * @return ApiResponse&lt;SaveTransactionsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SaveTransactionsResponse> createTransactionWithHttpInfo(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull PostTransactionsWrapper data) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = createTransactionRequestBuilder(budgetId, data);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("createTransaction", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<SaveTransactionsResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<SaveTransactionsResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SaveTransactionsResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder createTransactionRequestBuilder(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull PostTransactionsWrapper data) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling createTransaction");
    }
    // verify the required parameter 'data' is set
    if (data == null) {
      throw new ApiException(400, "Missing the required parameter 'data' when calling createTransaction");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/transactions"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(data);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Deletes an existing transaction
   * Deletes a transaction
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param transactionId The id of the transaction (required)
   * @return TransactionResponse
   * @throws ApiException if fails to make API call
   */
  public TransactionResponse deleteTransaction(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String transactionId) throws ApiException {
    ApiResponse<TransactionResponse> localVarResponse = deleteTransactionWithHttpInfo(budgetId, transactionId);
    return localVarResponse.getData();
  }

  /**
   * Deletes an existing transaction
   * Deletes a transaction
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param transactionId The id of the transaction (required)
   * @return ApiResponse&lt;TransactionResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TransactionResponse> deleteTransactionWithHttpInfo(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String transactionId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = deleteTransactionRequestBuilder(budgetId, transactionId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("deleteTransaction", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<TransactionResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<TransactionResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<TransactionResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder deleteTransactionRequestBuilder(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String transactionId) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling deleteTransaction");
    }
    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      throw new ApiException(400, "Missing the required parameter 'transactionId' when calling deleteTransaction");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/transactions/{transaction_id}"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()))
        .replace("{transaction_id}", ApiClient.urlEncode(transactionId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Single transaction
   * Returns a single transaction
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param transactionId The id of the transaction (required)
   * @return TransactionResponse
   * @throws ApiException if fails to make API call
   */
  public TransactionResponse getTransactionById(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String transactionId) throws ApiException {
    ApiResponse<TransactionResponse> localVarResponse = getTransactionByIdWithHttpInfo(budgetId, transactionId);
    return localVarResponse.getData();
  }

  /**
   * Single transaction
   * Returns a single transaction
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param transactionId The id of the transaction (required)
   * @return ApiResponse&lt;TransactionResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TransactionResponse> getTransactionByIdWithHttpInfo(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String transactionId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getTransactionByIdRequestBuilder(budgetId, transactionId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getTransactionById", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<TransactionResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<TransactionResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<TransactionResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getTransactionByIdRequestBuilder(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String transactionId) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling getTransactionById");
    }
    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      throw new ApiException(400, "Missing the required parameter 'transactionId' when calling getTransactionById");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/transactions/{transaction_id}"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()))
        .replace("{transaction_id}", ApiClient.urlEncode(transactionId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List transactions
   * Returns budget transactions, excluding any pending transactions
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param sinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30). (optional)
   * @param type If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported. (optional)
   * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included. (optional)
   * @return TransactionsResponse
   * @throws ApiException if fails to make API call
   */
  public TransactionsResponse getTransactions(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    ApiResponse<TransactionsResponse> localVarResponse = getTransactionsWithHttpInfo(budgetId, sinceDate, type, lastKnowledgeOfServer);
    return localVarResponse.getData();
  }

  /**
   * List transactions
   * Returns budget transactions, excluding any pending transactions
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param sinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30). (optional)
   * @param type If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported. (optional)
   * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included. (optional)
   * @return ApiResponse&lt;TransactionsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TransactionsResponse> getTransactionsWithHttpInfo(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getTransactionsRequestBuilder(budgetId, sinceDate, type, lastKnowledgeOfServer);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getTransactions", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<TransactionsResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<TransactionsResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<TransactionsResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getTransactionsRequestBuilder(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling getTransactions");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/transactions"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "since_date";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("since_date", sinceDate));
    localVarQueryParameterBaseName = "type";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("type", type));
    localVarQueryParameterBaseName = "last_knowledge_of_server";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("last_knowledge_of_server", lastKnowledgeOfServer));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List account transactions
   * Returns all transactions for a specified account, excluding any pending transactions
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param accountId The id of the account (required)
   * @param sinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30). (optional)
   * @param type If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported. (optional)
   * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included. (optional)
   * @return TransactionsResponse
   * @throws ApiException if fails to make API call
   */
  public TransactionsResponse getTransactionsByAccount(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String accountId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    ApiResponse<TransactionsResponse> localVarResponse = getTransactionsByAccountWithHttpInfo(budgetId, accountId, sinceDate, type, lastKnowledgeOfServer);
    return localVarResponse.getData();
  }

  /**
   * List account transactions
   * Returns all transactions for a specified account, excluding any pending transactions
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param accountId The id of the account (required)
   * @param sinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30). (optional)
   * @param type If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported. (optional)
   * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included. (optional)
   * @return ApiResponse&lt;TransactionsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TransactionsResponse> getTransactionsByAccountWithHttpInfo(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String accountId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getTransactionsByAccountRequestBuilder(budgetId, accountId, sinceDate, type, lastKnowledgeOfServer);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getTransactionsByAccount", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<TransactionsResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<TransactionsResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<TransactionsResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getTransactionsByAccountRequestBuilder(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String accountId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling getTransactionsByAccount");
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getTransactionsByAccount");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/accounts/{account_id}/transactions"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()))
        .replace("{account_id}", ApiClient.urlEncode(accountId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "since_date";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("since_date", sinceDate));
    localVarQueryParameterBaseName = "type";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("type", type));
    localVarQueryParameterBaseName = "last_knowledge_of_server";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("last_knowledge_of_server", lastKnowledgeOfServer));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List category transactions, excluding any pending transactions
   * Returns all transactions for a specified category
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param categoryId The id of the category (required)
   * @param sinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30). (optional)
   * @param type If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported. (optional)
   * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included. (optional)
   * @return HybridTransactionsResponse
   * @throws ApiException if fails to make API call
   */
  public HybridTransactionsResponse getTransactionsByCategory(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String categoryId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    ApiResponse<HybridTransactionsResponse> localVarResponse = getTransactionsByCategoryWithHttpInfo(budgetId, categoryId, sinceDate, type, lastKnowledgeOfServer);
    return localVarResponse.getData();
  }

  /**
   * List category transactions, excluding any pending transactions
   * Returns all transactions for a specified category
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param categoryId The id of the category (required)
   * @param sinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30). (optional)
   * @param type If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported. (optional)
   * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included. (optional)
   * @return ApiResponse&lt;HybridTransactionsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<HybridTransactionsResponse> getTransactionsByCategoryWithHttpInfo(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String categoryId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getTransactionsByCategoryRequestBuilder(budgetId, categoryId, sinceDate, type, lastKnowledgeOfServer);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getTransactionsByCategory", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<HybridTransactionsResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<HybridTransactionsResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<HybridTransactionsResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getTransactionsByCategoryRequestBuilder(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String categoryId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling getTransactionsByCategory");
    }
    // verify the required parameter 'categoryId' is set
    if (categoryId == null) {
      throw new ApiException(400, "Missing the required parameter 'categoryId' when calling getTransactionsByCategory");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/categories/{category_id}/transactions"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()))
        .replace("{category_id}", ApiClient.urlEncode(categoryId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "since_date";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("since_date", sinceDate));
    localVarQueryParameterBaseName = "type";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("type", type));
    localVarQueryParameterBaseName = "last_knowledge_of_server";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("last_knowledge_of_server", lastKnowledgeOfServer));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List transactions in month, excluding any pending transactions
   * Returns all transactions for a specified month
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC)) (required)
   * @param sinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30). (optional)
   * @param type If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported. (optional)
   * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included. (optional)
   * @return HybridTransactionsResponse
   * @throws ApiException if fails to make API call
   */
  public HybridTransactionsResponse getTransactionsByMonth(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String month, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    ApiResponse<HybridTransactionsResponse> localVarResponse = getTransactionsByMonthWithHttpInfo(budgetId, month, sinceDate, type, lastKnowledgeOfServer);
    return localVarResponse.getData();
  }

  /**
   * List transactions in month, excluding any pending transactions
   * Returns all transactions for a specified month
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC)) (required)
   * @param sinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30). (optional)
   * @param type If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported. (optional)
   * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included. (optional)
   * @return ApiResponse&lt;HybridTransactionsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<HybridTransactionsResponse> getTransactionsByMonthWithHttpInfo(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String month, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getTransactionsByMonthRequestBuilder(budgetId, month, sinceDate, type, lastKnowledgeOfServer);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getTransactionsByMonth", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<HybridTransactionsResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<HybridTransactionsResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<HybridTransactionsResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getTransactionsByMonthRequestBuilder(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String month, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling getTransactionsByMonth");
    }
    // verify the required parameter 'month' is set
    if (month == null) {
      throw new ApiException(400, "Missing the required parameter 'month' when calling getTransactionsByMonth");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/months/{month}/transactions"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()))
        .replace("{month}", ApiClient.urlEncode(month.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "since_date";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("since_date", sinceDate));
    localVarQueryParameterBaseName = "type";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("type", type));
    localVarQueryParameterBaseName = "last_knowledge_of_server";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("last_knowledge_of_server", lastKnowledgeOfServer));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List payee transactions, excluding any pending transactions
   * Returns all transactions for a specified payee
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param payeeId The id of the payee (required)
   * @param sinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30). (optional)
   * @param type If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported. (optional)
   * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included. (optional)
   * @return HybridTransactionsResponse
   * @throws ApiException if fails to make API call
   */
  public HybridTransactionsResponse getTransactionsByPayee(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String payeeId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    ApiResponse<HybridTransactionsResponse> localVarResponse = getTransactionsByPayeeWithHttpInfo(budgetId, payeeId, sinceDate, type, lastKnowledgeOfServer);
    return localVarResponse.getData();
  }

  /**
   * List payee transactions, excluding any pending transactions
   * Returns all transactions for a specified payee
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param payeeId The id of the payee (required)
   * @param sinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30). (optional)
   * @param type If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported. (optional)
   * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included. (optional)
   * @return ApiResponse&lt;HybridTransactionsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<HybridTransactionsResponse> getTransactionsByPayeeWithHttpInfo(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String payeeId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getTransactionsByPayeeRequestBuilder(budgetId, payeeId, sinceDate, type, lastKnowledgeOfServer);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getTransactionsByPayee", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<HybridTransactionsResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<HybridTransactionsResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<HybridTransactionsResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getTransactionsByPayeeRequestBuilder(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String payeeId, @jakarta.annotation.Nullable LocalDate sinceDate, @jakarta.annotation.Nullable String type, @jakarta.annotation.Nullable Long lastKnowledgeOfServer) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling getTransactionsByPayee");
    }
    // verify the required parameter 'payeeId' is set
    if (payeeId == null) {
      throw new ApiException(400, "Missing the required parameter 'payeeId' when calling getTransactionsByPayee");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/payees/{payee_id}/transactions"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()))
        .replace("{payee_id}", ApiClient.urlEncode(payeeId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "since_date";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("since_date", sinceDate));
    localVarQueryParameterBaseName = "type";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("type", type));
    localVarQueryParameterBaseName = "last_knowledge_of_server";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("last_knowledge_of_server", lastKnowledgeOfServer));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Import transactions
   * Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \&quot;Import\&quot; on each account in the web application or tapping the \&quot;New Transactions\&quot; banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @return TransactionsImportResponse
   * @throws ApiException if fails to make API call
   */
  public TransactionsImportResponse importTransactions(@jakarta.annotation.Nonnull String budgetId) throws ApiException {
    ApiResponse<TransactionsImportResponse> localVarResponse = importTransactionsWithHttpInfo(budgetId);
    return localVarResponse.getData();
  }

  /**
   * Import transactions
   * Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \&quot;Import\&quot; on each account in the web application or tapping the \&quot;New Transactions\&quot; banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @return ApiResponse&lt;TransactionsImportResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TransactionsImportResponse> importTransactionsWithHttpInfo(@jakarta.annotation.Nonnull String budgetId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = importTransactionsRequestBuilder(budgetId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("importTransactions", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<TransactionsImportResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<TransactionsImportResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<TransactionsImportResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder importTransactionsRequestBuilder(@jakarta.annotation.Nonnull String budgetId) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling importTransactions");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/transactions/import"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Updates an existing transaction
   * Updates a single transaction
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param transactionId The id of the transaction (required)
   * @param data The transaction to update (required)
   * @return TransactionResponse
   * @throws ApiException if fails to make API call
   */
  public TransactionResponse updateTransaction(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String transactionId, @jakarta.annotation.Nonnull PutTransactionWrapper data) throws ApiException {
    ApiResponse<TransactionResponse> localVarResponse = updateTransactionWithHttpInfo(budgetId, transactionId, data);
    return localVarResponse.getData();
  }

  /**
   * Updates an existing transaction
   * Updates a single transaction
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param transactionId The id of the transaction (required)
   * @param data The transaction to update (required)
   * @return ApiResponse&lt;TransactionResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TransactionResponse> updateTransactionWithHttpInfo(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String transactionId, @jakarta.annotation.Nonnull PutTransactionWrapper data) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateTransactionRequestBuilder(budgetId, transactionId, data);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateTransaction", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<TransactionResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<TransactionResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<TransactionResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateTransactionRequestBuilder(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull String transactionId, @jakarta.annotation.Nonnull PutTransactionWrapper data) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling updateTransaction");
    }
    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      throw new ApiException(400, "Missing the required parameter 'transactionId' when calling updateTransaction");
    }
    // verify the required parameter 'data' is set
    if (data == null) {
      throw new ApiException(400, "Missing the required parameter 'data' when calling updateTransaction");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/transactions/{transaction_id}"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()))
        .replace("{transaction_id}", ApiClient.urlEncode(transactionId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(data);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Update multiple transactions
   * Updates multiple transactions, by &#x60;id&#x60; or &#x60;import_id&#x60;.
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param data The transactions to update. Each transaction must have either an &#x60;id&#x60; or &#x60;import_id&#x60; specified. If &#x60;id&#x60; is specified as null an &#x60;import_id&#x60; value can be provided which will allow transaction(s) to be updated by its &#x60;import_id&#x60;. If an &#x60;id&#x60; is specified, it will always be used for lookup.  You should not specify both &#x60;id&#x60; and &#x60;import_id&#x60;.  Updating an &#x60;import_id&#x60; on an existing transaction is not allowed; if an &#x60;import_id&#x60; is specified, it will only be used to lookup the transaction. (required)
   * @return SaveTransactionsResponse
   * @throws ApiException if fails to make API call
   */
  public SaveTransactionsResponse updateTransactions(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull PatchTransactionsWrapper data) throws ApiException {
    ApiResponse<SaveTransactionsResponse> localVarResponse = updateTransactionsWithHttpInfo(budgetId, data);
    return localVarResponse.getData();
  }

  /**
   * Update multiple transactions
   * Updates multiple transactions, by &#x60;id&#x60; or &#x60;import_id&#x60;.
   * @param budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget). (required)
   * @param data The transactions to update. Each transaction must have either an &#x60;id&#x60; or &#x60;import_id&#x60; specified. If &#x60;id&#x60; is specified as null an &#x60;import_id&#x60; value can be provided which will allow transaction(s) to be updated by its &#x60;import_id&#x60;. If an &#x60;id&#x60; is specified, it will always be used for lookup.  You should not specify both &#x60;id&#x60; and &#x60;import_id&#x60;.  Updating an &#x60;import_id&#x60; on an existing transaction is not allowed; if an &#x60;import_id&#x60; is specified, it will only be used to lookup the transaction. (required)
   * @return ApiResponse&lt;SaveTransactionsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SaveTransactionsResponse> updateTransactionsWithHttpInfo(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull PatchTransactionsWrapper data) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateTransactionsRequestBuilder(budgetId, data);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateTransactions", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<SaveTransactionsResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<SaveTransactionsResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SaveTransactionsResponse>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateTransactionsRequestBuilder(@jakarta.annotation.Nonnull String budgetId, @jakarta.annotation.Nonnull PatchTransactionsWrapper data) throws ApiException {
    // verify the required parameter 'budgetId' is set
    if (budgetId == null) {
      throw new ApiException(400, "Missing the required parameter 'budgetId' when calling updateTransactions");
    }
    // verify the required parameter 'data' is set
    if (data == null) {
      throw new ApiException(400, "Missing the required parameter 'data' when calling updateTransactions");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/budgets/{budget_id}/transactions"
        .replace("{budget_id}", ApiClient.urlEncode(budgetId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(data);
      localVarRequestBuilder.method("PATCH", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
